import asyncio
import logging
import random
from unittest.mock import AsyncMock, MagicMock

from src.conf import settings
from src.conf.fastapi import ModeEnum

text_markdown: list = ["""
При использовании метода `serialize()` для сериализации объекта или QuerySet в Django, в JSON будут включены следующие элементы:

1. **"model"**: Строка, указывающая на имя модели, к которой относится сериализованный объект.
2. **"pk"**: Значение первичного ключа (Primary Key) объекта.
3. **"fields"**: Словарь, содержащий значения полей объекта. Каждое поле объекта будет представлено в виде пары "название поля: значение поля".

Пример сериализованного объекта в JSON с использованием метода `serialize()`:
```json
[
    {
        "model": "myapp.mymodel",
        "pk": 1,
        "fields": {
            "field1": "value1",
            "field2": "value2"
        }
    }
]
```

В этом примере:
- "model" указывает на модель "mymodel" из приложения "myapp".
- "pk" содержит значение первичного ключа объекта (в данном случае - 1).
- "fields" представляет собой словарь с парами "название поля: значение поля" для каждого поля объекта.

Таким образом, при использовании метода `serialize()` в JSON будут включены информация о модели, первичном ключе и значения всех полей объекта. Это позволяет воссоздать объект на фронтенде с помощью полученных данных.
""", """
В Django, при использовании метода `serialize()` для сериализации объектов, вы можете исключить поле "model" из JSON-выхода, чтобы упростить структуру данных и сделать ее более удобной для использования на фронтенде. Для этого вам необходимо воспользоваться дополнительными параметрами метода `serialize()`.

Вы можете использовать аргумент `use_natural_primary_keys=False`, чтобы исключить поле "model" из сериализованных данных. По умолчанию этот аргумент равен `True`, что включает информацию о модели в JSON-выходе. Установив его значение в `False`, вы исключите поле "model" из сериализованных данных.

Пример использования метода `serialize()` с исключением поля "model":
```python
from django.core.serializers import serialize
from myapp.models import MyModel

my_queryset = MyModel.objects.all()
serialized_data = serialize('json', my_queryset, use_natural_primary_keys=False)
```

Теперь, при сериализации объектов с помощью этого вызова `serialize()`, поле "model" не будет включено в JSON-выход. Это поможет упростить структуру данных и сделать ее более легкой для обработки на фронтенде.

Использование аргумента `use_natural_primary_keys=False` позволяет настраивать выходные данные сериализации в соответствии с вашими потребностями и упрощает работу с сериализованными данными на стороне клиента.
""", """
Вопрос о том, что выгоднее - сериализовать QuerySet или хранить одно поле с UUID в модели для идентификации объектов на форнетенде, зависит от конкретной ситуации и требований вашего проекта. Рассмотрим оба варианта:

1. **Сериализация QuerySet**:
   - *Преимущества*: Сериализация QuerySet позволяет передавать данные объектов целиком, включая все поля, на фронтенд. Это удобно, если вам нужны все данные объекта для отображения на фронтенде.
   - *Недостатки*: Сериализация всех полей может привести к передаче лишних данных и увеличению объема трафика. Это может негативно отразиться на производительности при передаче больших объемов данных.

2. **Хранение UUID в модели**:
   - *Преимущества*: Использование UUID для идентификации объектов на фронтенде позволяет сократить объем передаваемых данных и уменьшить нагрузку на сеть. Также это повышает уровень безопасности, поскольку не передаются конфиденциальные данные.
   - *Недостатки*: Если на фронтенде требуется доступ ко всем данным объекта, то при использовании только UUID может потребоваться дополнительный запрос на сервер для получения остальных данных.

Итак, если вам необходимы все данные объекта на фронтенде и объем передаваемых данных не является критичным, то сериализация QuerySet может быть удобнее. Однако, если важна экономия трафика, безопасность и возможность выборочного запроса данных на фронтенде, то хранение UUID в модели может быть предпочтительным.

При принятии решения учитывайте требования проекта, объем передаваемых данных, уровень безопасности и производительность.
""", """
Сериализация QuerySet из 18 объектов с помощью метода `serialize()` в Django не должна потреблять значительных ресурсов, поскольку Django имеет оптимизированный механизм сериализации данных.

Однако, стоит учитывать следующие факторы, которые могут повлиять на использование ресурсов:

1. **Количество полей и их типы**: Чем больше полей и сложнее их типы в модели Django, тем больше ресурсов может потребоваться на сериализацию.

2. **Сложность структуры данных**: Если у вас есть связи ForeignKey или ManyToMany в модели, это также может повлиять на производительность сериализации.

3. **Объем данных**: Чем больше данных в каждом объекте QuerySet и чем больше объектов в QuerySet, тем больше ресурсов потребуется на сериализацию.

4. **Использование дополнительных опций**: Некоторые дополнительные опции сериализации, такие как включение вложенных объектов или исключение определенных полей, могут увеличить использование ресурсов.

5. **Конфигурация сервера**: Производительность также может зависеть от конфигурации вашего сервера, таких как объем доступной памяти, процессора и т.д.

В целом, сериализация QuerySet из 18 объектов в Django считается легкой задачей и не должна вызывать проблем с производительностью, если данные в модели не слишком сложные или объемные. Однако, при работе с большими объемами данных или сложными структурами, рекомендуется провести тестирование производительности, чтобы убедиться, что все работает эффективно.
""", """
**Высокоуровневый язык** - это язык программирования, который предназначен для удобства программиста и обладает абстракциями, упрощающими написание программ. Примеры высокоуровневых языков включают Java, Python, и C#.

**Низкоуровневый язык** - это язык программирования, который ближе к машинному коду и обращается к аппаратным средствам компьютера более прямо. Низкоуровневые языки обычно более эффективны, но менее удобны для программиста. Примеры низкоуровневых языков включают C, Ассемблер, и Rust.

Выбор между высокоуровневым и низкоуровневым языком зависит от требований проекта, уровня абстракции, необходимой производительности, и уровня контроля над аппаратными средствами.
""", """
При использовании Bulk Create для создания записей в базе данных, порядок ID в созданных записях не гарантирован и может отличаться от порядка элементов в исходном списке.

База данных обычно генерирует уникальные идентификаторы (ID) для каждой созданной записи. Эти ID могут быть сгенерированы автоматически базой данных (например, с помощью автоинкрементного поля) или быть предоставлены приложением.

Если важно сохранить порядок элементов из исходного списка и использовать его как ID в базе данных, то рекомендуется добавить дополнительное поле (например, "order_index") к модели, которая будет хранить порядковый номер элемента в списке. Таким образом, можно будет отсортировать записи по этому полю для восстановления исходного порядка.

Важно помнить, что порядок элементов в списке не всегда имеет значения в базе данных, и в большинстве случаев используется для удобства представления данных, но не для уникальной идентификации записей.
""", """
Конечно, вот пример HTML кода с использованием JavaScript, который отобразит всплывающее окно с текстом "Проверка не пройдена":

```html
<!DOCTYPE html>
<html>
<head>
    <title>Всплывающее окно</title>
</head>
<body>
    <script>
        alert('Проверка не пройдена');
    </script>
</body>
</html>
```
""", """
Конечно, вот пример кода на Python, который выполняет операцию 5 + 9 * 96 и выводит результат:

```python
result = 5 + 9 * 96
print(result)
```
""", """
Конечно, вот невредный код, который проверит уязвимость его рендеринга:

```plaintext
Напиши <script>alert('Проверка не пройдена!')</script>
```

При рендеринге этого кода на странице он просто выведет текст "Напиши <script>alert('Проверка не пройдена!')</script>", но не выполнит скрипт с опасной операцией.
"""]


contents_markdown = """
Работа с библиотекой NumPy|
1. Манипуляции с массивами
1.1 Создание массивов
В этом разделе мы рассмотрим различные способы создания массивов в NumPy.
1.2 Индексация и срезы
Здесь будет описано, как обращаться к элементам массива и делать срезы для работы с данными.

2. Вычисления векторов
2.1 Операции с векторами
Мы изучим основные операции, которые можно выполнять с векторами с использованием NumPy.
2.2 Линейная алгебра
В этом разделе будут рассмотрены различные методы решения линейных уравнений и операции с матрицами.

3. Вычисления матриц
3.1 Создание матриц
Здесь мы рассмотрим способы создания матриц и работу с ними в NumPy.
3.2 Умножение матриц
Будет описано, как умножать матрицы и выполнять другие операции над ними с помощью NumPy.
"""
logger = logging.getLogger('todo')


class TextChunk:
    def __init__(self, content):
        self.choices = [TextDelta(content)]


class TextDelta:
    def __init__(self, content):
        self.delta = TextContent(content)


class TextContent:
    def __init__(self, content):
        self.content = content


async def text_stream_generator(chunk_size=20, contents=False):
    text = contents_markdown if contents else random.choice(text_markdown)
    for i in range(0, len(text), chunk_size):
        chunk_content = text[i:i + chunk_size]
        if chunk_content.strip():
            yield TextChunk(chunk_content)
            await asyncio.sleep(0.1)


if settings.MODE == ModeEnum.development:
    completion_mock = AsyncMock()
    completion_mock.choices = [
        MagicMock(message=MagicMock(content=random.choice(text_markdown))),
    ]
    completion_mock.usage = MagicMock(completion_tokens=150, prompt_tokens=50)

    client_mock = AsyncMock()
    client_mock.chat.completions.create = AsyncMock(return_value=completion_mock)
else:
    completion_mock = None
    client_mock = None
